// *** GENERAL CONSTRAINTS ***


if(platform->getInterconnectType() == TDMA_BUS){
  for(unsigned int ki=0; ki<channels.size(); ki++){
    int src_ch1 = channels[ki]->source;
    int dst_ch1 = channels[ki]->destination;
    int tok_ch1 = channels[ki]->initTokens;
    
    //cout << "channel (" << src_ch1 << " -> " << dst_ch1 << "): " << tok_ch1 << " inital tokens" << endl;

    //receiving doesn't take any time on TDMA bus (buffer in receiving node's local memory)
    rel(*this, wcct_r[ki]==0); 
    //if src and dst actors are located on same proc, communication doesn't take any time
    rel(*this, (proc[src_ch1]==proc[dst_ch1]) >> (wcct_b[ki]==0));
    rel(*this, (proc[src_ch1]==proc[dst_ch1]) >> (wcct_s[ki]==0));
    rel(*this, (proc[src_ch1]==proc[dst_ch1]) >> (recbufferSz[ki]==1));
    rel(*this, (proc[src_ch1]==proc[dst_ch1]) >> (sendbufferSz[ki]==0));
    //if src and dst actors are on different proc, wcct is sum of blocking and transfer time
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (wcct_b[ki] == blockingTime_s[ki]));
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (wcct_s[ki] == transferTime_s[ki]));
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (wcct_b[ki] > 0));
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (wcct_s[ki] > 0));
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (recbufferSz[ki]>=1));
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (sendbufferSz[ki]>=1));
    
    //blocking and transfer times for all channels, depending on TDMA allocation
    //Does element exist in a reified version?
    IntVarArgs bt_sj(*this, platform->nodes(), 0, Int::Limits::max);
    IntVarArgs tt_sj(*this, platform->nodes(), 0, Int::Limits::max);
    //cout << "   Blocking: ";
    IntArgs wcbts(mapping->wcBlockingTimes()); //blocking
    //for(int i=0; i<wcbts.size(); i++){
            //cout << wcbts[i] << " ";

    //}
    //cout << endl;
    //cout << "   Transfer: ";
    IntArgs wctts(mapping->wcTransferTimes(ki)); //transfer
    //for(int i=0; i<wctts.size(); i++){
        //cout << wctts[i] << " ";

    //}
    //cout << endl;
    for(size_t j=0; j<platform->nodes(); j++){
      element(*this, wcbts, tdmaAlloc[j], bt_sj[j]);
      element(*this, wctts, tdmaAlloc[j], tt_sj[j]);
    }
    element(*this, bt_sj, proc[src_ch1], blockingTime_s[ki]);
    element(*this, tt_sj, proc[src_ch1], transferTime_s[ki]);
    
    //order-based scheduling of messages
    rel(*this, sendNext[ki]!=ki);
    rel(*this, (sendNext[ki]>=apps->n_programChannels()) >> (sendNext[ki]==apps->n_programChannels()+proc[src_ch1]));
    rel(*this, recNext[ki]!=ki);
    rel(*this, (recNext[ki]>=apps->n_programChannels()) >> (recNext[ki]==apps->n_programChannels()+proc[dst_ch1]));
   
    for(unsigned int kj=0; kj<channels.size(); kj++){
      int src_ch2 = channels[kj]->source;
      int dst_ch2 = channels[kj]->destination;
      int tok_ch2 = channels[kj]->initTokens;
      if(ki != kj){
        //sending
        rel(*this, (proc[src_ch1]==proc[src_ch2] && rank[src_ch1] < rank[src_ch2]) >> (sendNext[kj]!=ki));
        rel(*this, (proc[src_ch1]!=proc[src_ch2]) >> (sendNext[kj]!=ki));
        if(src_ch1==src_ch2){
          //TODO: think about the role of inital tokens for this case. Intuitively, (if proc[dst_ch1]!=proc[dst_ch2]),
          //the channel without initial tokens should communicate first. But are there situations where it is
          //advantageous to not do that?
          rel(*this, (proc[dst_ch1]==proc[dst_ch2] && rank[dst_ch1] < rank[dst_ch2]) >> (sendNext[kj] != ki)); 
          if(tok_ch1==tok_ch2){
            rel(*this, (proc[dst_ch1]!=proc[dst_ch2] && proc[src_ch1]==proc[dst_ch1]) >> (sendNext[kj] != ki)); 
          }
          if(apps->dependsOn(dst_ch1,dst_ch2)){ 
            rel(*this, sendNext[kj] != ki); 
          }
        }
        //receiving
        //if(tok_ch1==0 && tok_ch2==0)
        rel(*this, (proc[dst_ch1]==proc[dst_ch2] && rank[dst_ch1] < rank[dst_ch2]) >> (recNext[kj]!=ki));
        rel(*this, (proc[dst_ch1]!=proc[dst_ch2]) >> (recNext[kj]!=ki));
        if(dst_ch1==dst_ch2){
          if(tok_ch1==tok_ch2){ //if both channels have the same amount of initial tokens (none or one)
            rel(*this, (proc[src_ch1]==proc[src_ch2] && rank[src_ch1] < rank[src_ch2]) >> (recNext[kj] != ki));
            rel(*this, (proc[src_ch1]!=proc[src_ch2] && proc[src_ch1]==proc[dst_ch1]) >> (recNext[kj] != ki));
          }else if(tok_ch1<tok_ch2){ //ch1 has no initial token, but ch2 does
            //TODO: investigate this situation (see more info on TODO list)
          }
          //The constraint below, as equivalent to the sending-version, does not make
          //sense for receiving order. Depending on sending times (token size, tdma allocation), the token from src_ch2
          //may arrive earlier than the token from src_ch1
          //if(apps->dependsOn(src_ch1,src_ch2)){ 
          //  rel(*this, recNext[ki] < recNext[kj]); 
          //}
        }
      }
    }

    //ordering of dummy nodes
    for(size_t j=0; j<platform->nodes(); j++){
      if(j<platform->nodes()-1){
        rel(*this, (proc[src_ch1]!=j+1) >> (sendNext[apps->n_programChannels()+j]!=ki));
        rel(*this, (proc[dst_ch1]!=j+1) >> (recNext[apps->n_programChannels()+j]!=ki));
        rel(*this, sendNext[apps->n_programChannels()+j]<apps->n_programChannels() 
                   || sendNext[apps->n_programChannels()+j]==apps->n_programChannels()+j+1);
        rel(*this, recNext[apps->n_programChannels()+j]<apps->n_programChannels() 
                   || recNext[apps->n_programChannels()+j]==apps->n_programChannels()+j+1);
      }else{
        rel(*this, (proc[src_ch1]!=0) >> (sendNext[apps->n_programChannels()+j]!=ki));
        rel(*this, (proc[dst_ch1]!=0) >> (recNext[apps->n_programChannels()+j]!=ki));
        rel(*this, sendNext[apps->n_programChannels()+j]<apps->n_programChannels() 
                   || sendNext[apps->n_programChannels()+j]==apps->n_programChannels());
        rel(*this, recNext[apps->n_programChannels()+j]<apps->n_programChannels() 
                   || recNext[apps->n_programChannels()+j]==apps->n_programChannels());
      }
    }
  }
  circuit(*this, sendNext, ICL_DOM);
  circuit(*this, recNext, ICL_DOM);
  
  //TDMA slot allocation
  //count how many channels on each proc communicate via the bus
  IntVarArgs sendingProcs(*this, apps->n_programChannels(), 0, platform->nodes()+1);
  IntVarArgs channelsOnProc(*this, platform->nodes()+1, 0, apps->n_programChannels());
  for(unsigned int ki=0; ki<channels.size(); ki++){
    int src_ch = channels[ki]->source;
    int dst_ch = channels[ki]->destination;
    for(size_t j=0; j<platform->nodes(); j++){
      rel(*this, (proc[src_ch]==j && proc[src_ch]!=proc[dst_ch]) >> (sendingProcs[ki]==j));
    }
    rel(*this, (proc[src_ch]==proc[dst_ch]) >> (sendingProcs[ki]==platform->nodes()));
  }
  count(*this, sendingProcs, channelsOnProc);
  for(size_t j=0; j<platform->nodes(); j++){
    //if all actors are on the same node, no communication via the bus
    rel(*this, (procsUsed==1) >> (tdmaAlloc[j]==0));
    //if no messages are sent from proc, allocate no tdma slots
    rel(*this, (channelsOnProc[j]==0) == (tdmaAlloc[j]==0));
    //...otherwise, allocate at least one slot
    rel(*this, (channelsOnProc[j]>0) >> (tdmaAlloc[j]>0));
  }
  rel(*this, sum(tdmaAlloc) <= platform->tdmaSlots());
  
} else if(platform->getInterconnectType() == TDN_NOC){ //TDN-NoC ~~~~~~~
  vector<tdn_graphNode> tdn_graph = platform->getTDNGraph();
  LOG_INFO("TDN graph is of size " + tools::toString(tdn_graph.size()));
  Matrix<IntVarArray> tdnTableM(tdnTable, platform->getTDNCycles(), tdn_graph.size()/platform->getTDNCycles());
  IntVarArgs hops(*this, apps->n_programChannels(), 0, platform->getMaxNoCHops());
  IntVarArgs chosenRoute(*this, apps->n_programChannels(), 0, platform->getTDNCycles());
  
  //initial constraints on TDN (injection and state of NoC) table:
  //which process can access which link
  for(size_t t=0; t<tdn_graph.size(); t++){
    vector<int> passingProcs(tdn_graph[t].passingProcs.begin(), tdn_graph[t].passingProcs.end());
    passingProcs.push_back(platform->nodes());
    IntArgs passingProcsArgs(passingProcs);
    IntSet passingProcsDomain(passingProcsArgs);
    
    dom(*this, tdnTable[t], passingProcsDomain);
  }
  
  //for(size_t t=0; t<platform->getTDNCycles()*platform->nodes(); t++){
  
  
  for(size_t ji=0; ji<platform->nodes(); ji++){
    cout << "I am processor " << ji << ". I can travel to..." << endl;
    int dst = 0;
    for(size_t jj=0; jj<platform->nodes(); jj++){
    //for(size_t r=0; r<tdn_graph[t].tdn_routes.size(); r++){
      if(ji!=jj){
        IntVarArgs routes;
        int routeHops;
        cout << "... processor " << jj << endl;
        for(size_t k=0; k<platform->getTDNCycles(); k++){
          int t = ji * platform->getTDNCycles() + k;
          routeHops = tdn_graph[t].tdn_routes[dst]->tdn_nodePath.size();
          cout << "\t like this: " << tools::toString(tdn_graph[t].tdn_routes[dst]->tdn_nodePath) << endl;
        }
        
        for(size_t k=0; k<platform->getTDNCycles(); k++){
          int t = ji * platform->getTDNCycles() + k;
          for(unsigned int ki=0; ki<channels.size(); ki++){
            int src_ch1 = channels[ki]->source;
            int dst_ch1 = channels[ki]->destination;
            int tok_ch1 = channels[ki]->initTokens;
            
            //if allocated TDN cycles is restricted to 1
            //BoolVar useThisRoute = expr(*this, (proc[src_ch1]==ji) && (proc[dst_ch1]==jj) && (chosenRoute[ki]==k));
            //Reify r(useThisRoute, RM_IMP);
            //rel(*this, routesM.row(k), IRT_EQ, tdnTable[ji*platform->getTDNCycles()+k]);//, r);
            for(size_t r=0; r<tdn_graph[t].tdn_routes[dst]->tdn_nodePath.size(); r++){
              rel(*this, ((proc[src_ch1]==ji) && (proc[dst_ch1]==jj) && (chosenRoute[ki]==k))
                  >> (tdnTable[tdn_graph[t].tdn_routes[dst]->tdn_nodePath[r]]==ji));
              //if processor ji does not have TDN slot k, it cannot use the route
              //if(r>0){
              //  rel(*this, (tdnTable[tdn_graph[t].tdn_routes[dst]->tdn_nodePath[0]]!=ji)
              //              >> (tdnTable[tdn_graph[t].tdn_routes[dst]->tdn_nodePath[r]]!=ji));
              //}
            }
          }
        }
        dst++;
      }
    }
  }
  
  for(int t=platform->getTDNCycles()*platform->nodes(); t<tdn_graph.size()-platform->getTDNCycles()*platform->nodes(); t++){
    cout << "Routes going through TDN graph node " << t << ": [";
    cout << tdn_graph[t].link.from << " -> " << tdn_graph[t].link.to << " @" << tdn_graph[t].link.cycle << "]"  << endl;
    for(size_t r=0; r<tdn_graph[t].tdn_routes.size(); r++){
      cout << "\t" << tools::toString(tdn_graph[t].tdn_routes[r]->tdn_nodePath) << endl;
    }
  }
  
  //for TDN cycle allocation:
  //count how many channels on each proc communicate via the bus
  IntVarArgs sendingProcs(*this, apps->n_programChannels(), 0, platform->nodes()+1);
  IntVarArgs channelsOnProc(*this, platform->nodes()+1, 0, apps->n_programChannels());
  for(unsigned int ki=0; ki<channels.size(); ki++){
    int src_ch = channels[ki]->source;
    int dst_ch = channels[ki]->destination;
    for(size_t j=0; j<platform->nodes(); j++){
      rel(*this, (proc[src_ch]==j && proc[src_ch]!=proc[dst_ch]) >> (sendingProcs[ki]==j));
    }
    rel(*this, (proc[src_ch]==proc[dst_ch]) >> (sendingProcs[ki]==platform->nodes()));
  }
  count(*this, sendingProcs, channelsOnProc);
  
  for(size_t j=0; j<platform->nodes(); j++){
    //if there is trafik from j, then at least one TDN cycle must
    //be assigned to j
    rel(*this, (channelsOnProc[j]>0) >> (min(tdnTableM.row(j))==j));
    for(size_t t=0; t<tdn_graph.size(); t++){
      //if there are no sending channels on j, remove j from TDN table
      rel(*this, (channelsOnProc[j]==0) >> (tdnTable[t]!=j));
    }
  }
  
  
  for(unsigned int ki=0; ki<channels.size(); ki++){
    int src_ch1 = channels[ki]->source;
    int dst_ch1 = channels[ki]->destination;
    int tok_ch1 = channels[ki]->initTokens;
    
    
    //TDN slot allocation (injection table)
    
    
    //blocking and transfer times:
    
    //receiving doesn't take any time on TDN NoC (buffer in receiving node's local memory)
    rel(*this, wcct_r[ki]==0); 
    //if src and dst actors are located on same proc, communication doesn't take any time
    rel(*this, (proc[src_ch1]==proc[dst_ch1]) >> (wcct_b[ki]==0));
    rel(*this, (proc[src_ch1]==proc[dst_ch1]) >> (wcct_s[ki]==0));
    rel(*this, (proc[src_ch1]==proc[dst_ch1]) >> (recbufferSz[ki]==1));
    rel(*this, (proc[src_ch1]==proc[dst_ch1]) >> (sendbufferSz[ki]==0));
    rel(*this, (proc[src_ch1]==proc[dst_ch1]) >> (chosenRoute[ki]==platform->getTDNCycles()));
    //if src and dst actors are on different proc, wcct consists of blocking and transfer time
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (wcct_b[ki] == blockingTime_s[ki]));
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (wcct_s[ki] == transferTime_s[ki]));
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (wcct_b[ki] > 0));
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (wcct_s[ki] > 0));
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (recbufferSz[ki]>=1));
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (sendbufferSz[ki]>=1));
    rel(*this, (proc[src_ch1]!=proc[dst_ch1]) >> (chosenRoute[ki]<platform->getTDNCycles()));
    
    
  
    //order-based scheduling of messages:
    rel(*this, sendNext[ki]!=ki);
    rel(*this, (sendNext[ki]>=apps->n_programChannels()) >> (sendNext[ki]==apps->n_programChannels()+proc[src_ch1]));
    rel(*this, recNext[ki]!=ki);
    rel(*this, (recNext[ki]>=apps->n_programChannels()) >> (recNext[ki]==apps->n_programChannels()+proc[dst_ch1]));
   
    for(unsigned int kj=0; kj<channels.size(); kj++){
      int src_ch2 = channels[kj]->source;
      int dst_ch2 = channels[kj]->destination;
      int tok_ch2 = channels[kj]->initTokens;
      if(ki != kj){
        //sending
        rel(*this, (proc[src_ch1]==proc[src_ch2] && rank[src_ch1] < rank[src_ch2]) >> (sendNext[kj]!=ki));
        rel(*this, (proc[src_ch1]!=proc[src_ch2]) >> (sendNext[kj]!=ki));
        if(src_ch1==src_ch2){
          //TODO: think about the role of inital tokens for this case. Intuitively, (if proc[dst_ch1]!=proc[dst_ch2]),
          //the channel without initial tokens should communicate first. But are there situations where it is
          //advantageous to not do that?
          rel(*this, (proc[dst_ch1]==proc[dst_ch2] && rank[dst_ch1] < rank[dst_ch2]) >> (sendNext[kj] != ki)); 
          if(tok_ch1==tok_ch2){
            rel(*this, (proc[dst_ch1]!=proc[dst_ch2] && proc[src_ch1]==proc[dst_ch1]) >> (sendNext[kj] != ki)); 
          }
          if(apps->dependsOn(dst_ch1,dst_ch2)){ 
            rel(*this, sendNext[kj] != ki); 
          }
        }
        //receiving
        //if(tok_ch1==0 && tok_ch2==0)
        rel(*this, (proc[dst_ch1]==proc[dst_ch2] && rank[dst_ch1] < rank[dst_ch2]) >> (recNext[kj]!=ki));
        rel(*this, (proc[dst_ch1]!=proc[dst_ch2]) >> (recNext[kj]!=ki));
        if(dst_ch1==dst_ch2){
          if(tok_ch1==tok_ch2){ //if both channels have the same amount of initial tokens (none or one)
            rel(*this, (proc[src_ch1]==proc[src_ch2] && rank[src_ch1] < rank[src_ch2]) >> (recNext[kj] != ki));
            rel(*this, (proc[src_ch1]!=proc[src_ch2] && proc[src_ch1]==proc[dst_ch1]) >> (recNext[kj] != ki));
          }else if(tok_ch1<tok_ch2){ //ch1 has no initial token, but ch2 does
            //TODO: investigate this situation (see more info on TODO list)
          }
          //The constraint below, as equivalent to the sending-version, does not make
          //sense for receiving order. Depending on sending times (token size, tdma allocation), the token from src_ch2
          //may arrive earlier than the token from src_ch1
          //if(apps->dependsOn(src_ch1,src_ch2)){ 
          //  rel(*this, recNext[ki] < recNext[kj]); 
          //}
        }
      }
    }

    //ordering of dummy nodes
    for(size_t j=0; j<platform->nodes(); j++){
      if(j<platform->nodes()-1){
        rel(*this, (proc[src_ch1]!=j+1) >> (sendNext[apps->n_programChannels()+j]!=ki));
        rel(*this, (proc[dst_ch1]!=j+1) >> (recNext[apps->n_programChannels()+j]!=ki));
        rel(*this, sendNext[apps->n_programChannels()+j]<apps->n_programChannels() 
                   || sendNext[apps->n_programChannels()+j]==apps->n_programChannels()+j+1);
        rel(*this, recNext[apps->n_programChannels()+j]<apps->n_programChannels() 
                   || recNext[apps->n_programChannels()+j]==apps->n_programChannels()+j+1);
      }else{
        rel(*this, (proc[src_ch1]!=0) >> (sendNext[apps->n_programChannels()+j]!=ki));
        rel(*this, (proc[dst_ch1]!=0) >> (recNext[apps->n_programChannels()+j]!=ki));
        rel(*this, sendNext[apps->n_programChannels()+j]<apps->n_programChannels() 
                   || sendNext[apps->n_programChannels()+j]==apps->n_programChannels());
        rel(*this, recNext[apps->n_programChannels()+j]<apps->n_programChannels() 
                   || recNext[apps->n_programChannels()+j]==apps->n_programChannels());
      }
    }
  }
  circuit(*this, sendNext, ICL_DOM);
  circuit(*this, recNext, ICL_DOM);
  
}
// *** CONSTRAINTS FORCING THE DESIGN DECISIONS ***


